---
title: å¸¸è§é™æµç®—æ³•å¯¹æ¯”ä¸ä»¤ç‰Œæ¡¶è¯¦è§£
published: 2025-10-19
description: å¸¸è§é™æµç®—æ³•å¯¹æ¯”ä¸ä»¤ç‰Œæ¡¶è¯¦è§£ï¼ŒåŒ…æ‹¬å›ºå®šçª—å£è®¡æ•°å™¨ã€æ»‘åŠ¨çª—å£è®¡æ•°å™¨ã€æ¼æ¡¶ç®—æ³•å’Œä»¤ç‰Œæ¡¶ç®—æ³•çš„åŸç†ã€ä¼˜ç‚¹ã€ç¼ºç‚¹å’Œé€‚ç”¨åœºæ™¯ã€‚
tags: [é¢ç», å¿«æ‰‹, é™æµç®—æ³•]
category: é¢ç»
draft: false
---

# å¸¸è§é™æµç®—æ³•å¯¹æ¯”ä¸ä»¤ç‰Œæ¡¶è¯¦è§£

## ä¸€ã€å››ç§é™æµç®—æ³•å¯¹æ¯”

### 1. **å›ºå®šçª—å£è®¡æ•°å™¨**

**åŸç†**ï¼šåœ¨å›ºå®šæ—¶é—´çª—å£å†…ç»Ÿè®¡è¯·æ±‚æ•°ï¼Œè¶…è¿‡é˜ˆå€¼åˆ™æ‹’ç»ã€‚

**ä¼˜ç‚¹**ï¼šå®ç°ç®€å•ï¼Œå†…å­˜å ç”¨å°
**ç¼ºç‚¹**ï¼šå­˜åœ¨"ä¸´ç•Œé—®é¢˜" - çª—å£è¾¹ç•Œå¯èƒ½å‡ºç° 2 å€æµé‡çªåˆº

```
çª—å£1: [0s-1s] å…è®¸100ä¸ªè¯·æ±‚
çª—å£2: [1s-2s] å…è®¸100ä¸ªè¯·æ±‚
é—®é¢˜ï¼š0.9s-1.1s å¯èƒ½é€šè¿‡200ä¸ªè¯·æ±‚
```

### 2. **æ»‘åŠ¨çª—å£è®¡æ•°å™¨**

**åŸç†**ï¼šå°†æ—¶é—´çª—å£åˆ‡åˆ†æˆå¤šä¸ªå°æ ¼å­ï¼Œç»Ÿè®¡æ»‘åŠ¨æ—¶é—´èŒƒå›´å†…çš„è¯·æ±‚æ€»æ•°ã€‚

**ä¼˜ç‚¹**ï¼šè§£å†³å›ºå®šçª—å£çš„ä¸´ç•Œé—®é¢˜ï¼Œæ›´å¹³æ»‘
**ç¼ºç‚¹**ï¼šéœ€è¦å­˜å‚¨å¤šä¸ªæ—¶é—´æ ¼å­çš„è®¡æ•°ï¼Œå†…å­˜å ç”¨è¾ƒå¤§

### 3. **æ¼æ¡¶ç®—æ³• (Leaky Bucket)**

**åŸç†**ï¼šè¯·æ±‚è¿›å…¥æ¼æ¡¶ï¼Œä»¥æ’å®šé€Ÿç‡æµå‡ºå¤„ç†ã€‚æ¡¶æ»¡åˆ™æº¢å‡ºæ‹’ç»ã€‚

**ä¼˜ç‚¹**ï¼šæµé‡æ•´å½¢æ•ˆæœå¥½ï¼Œè¾“å‡ºç»å¯¹å¹³æ»‘
**ç¼ºç‚¹**ï¼š**æ— æ³•åº”å¯¹çªå‘æµé‡**ï¼Œå³ä½¿ç³»ç»Ÿç©ºé—²ä¹Ÿæ— æ³•å¿«é€Ÿå¤„ç†

```
     è¯·æ±‚ â†“â†“â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  æ¼æ¡¶   â”‚
    â”‚ ~~~~~~  â”‚
    â””â”€â”€â”€â”€â†“â”€â”€â”€â”€â”˜
      æ’å®šé€Ÿç‡æµå‡º
```

### 4. **ä»¤ç‰Œæ¡¶ç®—æ³• (Token Bucket)** â­

**åŸç†**ï¼šä»¥æ’å®šé€Ÿç‡ç”Ÿæˆä»¤ç‰Œæ”¾å…¥æ¡¶ä¸­ï¼Œè¯·æ±‚éœ€è·å–ä»¤ç‰Œæ‰èƒ½é€šè¿‡ã€‚

**ä¼˜ç‚¹**ï¼š

- âœ… **æ”¯æŒçªå‘æµé‡** - æ¡¶ä¸­ç§¯ç´¯çš„ä»¤ç‰Œå¯ä¸€æ¬¡æ€§ä½¿ç”¨
- âœ… æ—¢èƒ½é™åˆ¶å¹³å‡é€Ÿç‡ï¼Œåˆæœ‰å¼¹æ€§
- âœ… é€‚åˆå¤§å¤šæ•°ä¸šåŠ¡åœºæ™¯

**ç¼ºç‚¹**ï¼šå®ç°ç›¸å¯¹å¤æ‚

---

## äºŒã€ä»¤ç‰Œæ¡¶ç®—æ³•è¯¦è§£

### å·¥ä½œåŸç†

```
ä»¤ç‰Œç”Ÿæˆå™¨ â†’ æ’å®šé€Ÿç‡r
                â†“
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   ä»¤ç‰Œæ¡¶ (å®¹é‡c) â”‚
    â”‚   ğŸª™ğŸª™ğŸª™ğŸª™ğŸª™     â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
           â†“ è·å–ä»¤ç‰Œ
        è¯·æ±‚å¤„ç†
```

**æ ¸å¿ƒæœºåˆ¶**ï¼š

1. ä»¤ç‰Œä»¥å›ºå®šé€Ÿç‡ `r` ç”Ÿæˆï¼ˆå¦‚æ¯ç§’ 100 ä¸ªï¼‰
2. æ¡¶çš„å®¹é‡ä¸º `c`ï¼ˆå¦‚æœ€å¤šå­˜ 200 ä¸ªä»¤ç‰Œï¼‰
3. è¯·æ±‚åˆ°è¾¾æ—¶å°è¯•è·å–ä»¤ç‰Œï¼š
   - æœ‰ä»¤ç‰Œï¼šè·å–æˆåŠŸï¼Œè¯·æ±‚é€šè¿‡
   - æ— ä»¤ç‰Œï¼šæ‹’ç»è¯·æ±‚æˆ–ç­‰å¾…
4. ä»¤ç‰Œæ»¡äº†ä¼šä¸¢å¼ƒæ–°ç”Ÿæˆçš„ä»¤ç‰Œ

### ä¸ºä»€ä¹ˆæ”¯æŒçªå‘æµé‡ï¼Ÿ

å‡è®¾ï¼šr=100/sï¼Œc=200

- **å¹³ç¨³æœŸ**ï¼š1 ç§’å†…æœ€å¤šå¤„ç† 100 ä¸ªè¯·æ±‚ï¼ˆæ¶ˆè€—=ç”Ÿæˆï¼‰
- **çªå‘æœŸ**ï¼šå¦‚æœä¹‹å‰ç³»ç»Ÿç©ºé—²ï¼Œæ¡¶ä¸­ç§¯ç´¯äº† 200 ä¸ªä»¤ç‰Œï¼Œæ­¤æ—¶å¯ç¬é—´å¤„ç† 200 ä¸ªè¯·æ±‚
- **é™åˆ¶**ï¼šçªå‘è¿‡åï¼Œä»æŒ‰ 100/s çš„å¹³å‡é€Ÿç‡å¤„ç†

---

## ä¸‰ã€å®ç°æ–¹å¼å¯¹æ¯”

### å•æœºå®ç°

- ä½¿ç”¨æœ¬åœ°å˜é‡å­˜å‚¨ä»¤ç‰Œæ•°å’Œæ—¶é—´æˆ³
- é€‚åˆå•ä½“åº”ç”¨
- æ€§èƒ½é«˜ï¼Œæ— ç½‘ç»œå¼€é”€

### åˆ†å¸ƒå¼å®ç°

å¸¸è§æ–¹æ¡ˆï¼š

1. **Redis + Lua è„šæœ¬**ï¼šä¿è¯åŸå­æ€§ï¼Œé€‚åˆä¸­å°è§„æ¨¡
2. **Redis + é™æµä¸­é—´ä»¶**ï¼ˆå¦‚ Sentinelï¼‰
3. **ç‹¬ç«‹é™æµæœåŠ¡**ï¼ˆå¦‚ Envoy Rate Limit Serviceï¼‰

**æ ¸å¿ƒæŒ‘æˆ˜**ï¼š

- åŸå­æ€§ï¼šä»¤ç‰Œè·å–å¿…é¡»æ˜¯åŸå­æ“ä½œ
- ä¸€è‡´æ€§ï¼šå¤šå®ä¾‹é—´çš„ä»¤ç‰Œè®¡æ•°åŒæ­¥
- æ€§èƒ½ï¼šå‡å°‘ç½‘ç»œè°ƒç”¨å¼€é”€

---

## å››ã€ä»£ç å®ç°

### Java å®ç°ï¼ˆå•æœºç‰ˆï¼‰

```java
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.ReentrantLock;

/**
 * ä»¤ç‰Œæ¡¶é™æµå™¨
 */
public class TokenBucketRateLimiter {
    // æ¡¶çš„å®¹é‡
    private final long capacity;
    // ä»¤ç‰Œç”Ÿæˆé€Ÿç‡ï¼ˆæ¯ç§’ï¼‰
    private final long refillRate;
    // å½“å‰ä»¤ç‰Œæ•°
    private long tokens;
    // ä¸Šæ¬¡åˆ·æ–°æ—¶é—´
    private long lastRefillTime;
    // çº¿ç¨‹å®‰å…¨é”
    private final ReentrantLock lock = new ReentrantLock();

    /**
     * @param capacity æ¡¶å®¹é‡ï¼ˆæœ€å¤§ä»¤ç‰Œæ•°ï¼‰
     * @param refillRate æ¯ç§’ç”Ÿæˆçš„ä»¤ç‰Œæ•°
     */
    public TokenBucketRateLimiter(long capacity, long refillRate) {
        this.capacity = capacity;
        this.refillRate = refillRate;
        this.tokens = capacity; // åˆå§‹åŒ–æ—¶æ¡¶æ˜¯æ»¡çš„
        this.lastRefillTime = System.nanoTime();
    }

    /**
     * å°è¯•è·å–æŒ‡å®šæ•°é‡çš„ä»¤ç‰Œ
     * @param tokensRequired éœ€è¦çš„ä»¤ç‰Œæ•°
     * @return æ˜¯å¦æˆåŠŸè·å–
     */
    public boolean tryAcquire(long tokensRequired) {
        lock.lock();
        try {
            refill();
            if (tokens >= tokensRequired) {
                tokens -= tokensRequired;
                return true;
            }
            return false;
        } finally {
            lock.unlock();
        }
    }

    /**
     * è·å–1ä¸ªä»¤ç‰Œ
     */
    public boolean tryAcquire() {
        return tryAcquire(1);
    }

    /**
     * é˜»å¡å¼è·å–ä»¤ç‰Œï¼Œç›´åˆ°æˆåŠŸ
     * @param tokensRequired éœ€è¦çš„ä»¤ç‰Œæ•°
     * @param timeout è¶…æ—¶æ—¶é—´
     * @param unit æ—¶é—´å•ä½
     * @return æ˜¯å¦åœ¨è¶…æ—¶å‰è·å–æˆåŠŸ
     */
    public boolean acquire(long tokensRequired, long timeout, TimeUnit unit)
            throws InterruptedException {
        long deadline = System.nanoTime() + unit.toNanos(timeout);

        while (System.nanoTime() < deadline) {
            if (tryAcquire(tokensRequired)) {
                return true;
            }
            // è®¡ç®—éœ€è¦ç­‰å¾…çš„æ—¶é—´
            long waitTime = (tokensRequired - tokens) * 1_000_000_000L / refillRate;
            if (waitTime > 0) {
                Thread.sleep(Math.min(waitTime / 1_000_000, 100));
            }
        }
        return false;
    }

    /**
     * è¡¥å……ä»¤ç‰Œ
     */
    private void refill() {
        long now = System.nanoTime();
        long elapsedTime = now - lastRefillTime;

        // è®¡ç®—è¿™æ®µæ—¶é—´åº”è¯¥ç”Ÿæˆçš„ä»¤ç‰Œæ•°
        long tokensToAdd = (elapsedTime * refillRate) / 1_000_000_000L;

        if (tokensToAdd > 0) {
            tokens = Math.min(capacity, tokens + tokensToAdd);
            lastRefillTime = now;
        }
    }

    /**
     * è·å–å½“å‰å¯ç”¨ä»¤ç‰Œæ•°
     */
    public long getAvailableTokens() {
        lock.lock();
        try {
            refill();
            return tokens;
        } finally {
            lock.unlock();
        }
    }

    // ä½¿ç”¨ç¤ºä¾‹
    public static void main(String[] args) throws InterruptedException {
        // åˆ›å»ºé™æµå™¨ï¼šå®¹é‡200ï¼Œæ¯ç§’ç”Ÿæˆ100ä¸ªä»¤ç‰Œ
        TokenBucketRateLimiter limiter = new TokenBucketRateLimiter(200, 100);

        System.out.println("=== æµ‹è¯•çªå‘æµé‡ ===");
        // æ¨¡æ‹Ÿçªå‘ï¼šç¬é—´150ä¸ªè¯·æ±‚
        int successCount = 0;
        for (int i = 0; i < 150; i++) {
            if (limiter.tryAcquire()) {
                successCount++;
            }
        }
        System.out.println("çªå‘150ä¸ªè¯·æ±‚ï¼Œé€šè¿‡: " + successCount);
        System.out.println("å‰©ä½™ä»¤ç‰Œ: " + limiter.getAvailableTokens());

        System.out.println("\n=== æµ‹è¯•æŒç»­æµé‡ ===");
        // æ¨¡æ‹ŸæŒç»­è¯·æ±‚
        for (int i = 0; i < 5; i++) {
            Thread.sleep(1000); // ç­‰å¾…1ç§’
            int pass = 0;
            for (int j = 0; j < 120; j++) {
                if (limiter.tryAcquire()) {
                    pass++;
                }
            }
            System.out.println("ç¬¬" + (i+1) + "ç§’: å°è¯•120ä¸ªè¯·æ±‚ï¼Œé€šè¿‡ " + pass);
        }

        System.out.println("\n=== æµ‹è¯•é˜»å¡è·å– ===");
        boolean acquired = limiter.acquire(10, 2, TimeUnit.SECONDS);
        System.out.println("é˜»å¡è·å–10ä¸ªä»¤ç‰Œ: " + (acquired ? "æˆåŠŸ" : "è¶…æ—¶"));
    }
}
```

### Go å®ç°ï¼ˆå•æœºç‰ˆï¼‰

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// TokenBucket ä»¤ç‰Œæ¡¶é™æµå™¨
type TokenBucket struct {
	capacity       int64         // æ¡¶å®¹é‡
	refillRate     int64         // æ¯ç§’ç”Ÿæˆçš„ä»¤ç‰Œæ•°
	tokens         int64         // å½“å‰ä»¤ç‰Œæ•°
	lastRefillTime time.Time     // ä¸Šæ¬¡åˆ·æ–°æ—¶é—´
	mu             sync.Mutex    // äº’æ–¥é”
}

// NewTokenBucket åˆ›å»ºä»¤ç‰Œæ¡¶
func NewTokenBucket(capacity, refillRate int64) *TokenBucket {
	return &TokenBucket{
		capacity:       capacity,
		refillRate:     refillRate,
		tokens:         capacity, // åˆå§‹åŒ–æ—¶æ¡¶æ˜¯æ»¡çš„
		lastRefillTime: time.Now(),
	}
}

// TryAcquire å°è¯•è·å–æŒ‡å®šæ•°é‡çš„ä»¤ç‰Œ
func (tb *TokenBucket) TryAcquire(tokensRequired int64) bool {
	tb.mu.Lock()
	defer tb.mu.Unlock()

	tb.refill()

	if tb.tokens >= tokensRequired {
		tb.tokens -= tokensRequired
		return true
	}
	return false
}

// TryAcquireOne å°è¯•è·å–1ä¸ªä»¤ç‰Œ
func (tb *TokenBucket) TryAcquireOne() bool {
	return tb.TryAcquire(1)
}

// Acquire é˜»å¡å¼è·å–ä»¤ç‰Œï¼Œç›´åˆ°æˆåŠŸæˆ–è¶…æ—¶
func (tb *TokenBucket) Acquire(tokensRequired int64, timeout time.Duration) bool {
	deadline := time.Now().Add(timeout)

	for time.Now().Before(deadline) {
		if tb.TryAcquire(tokensRequired) {
			return true
		}

		// è®¡ç®—éœ€è¦ç­‰å¾…çš„æ—¶é—´
		tb.mu.Lock()
		tb.refill()
		waitTokens := tokensRequired - tb.tokens
		tb.mu.Unlock()

		if waitTokens > 0 {
			waitTime := time.Duration(waitTokens*1e9/tb.refillRate) * time.Nanosecond
			if waitTime > 100*time.Millisecond {
				waitTime = 100 * time.Millisecond
			}
			time.Sleep(waitTime)
		}
	}
	return false
}

// refill è¡¥å……ä»¤ç‰Œï¼ˆéœ€è¦åœ¨æŒæœ‰é”çš„æƒ…å†µä¸‹è°ƒç”¨ï¼‰
func (tb *TokenBucket) refill() {
	now := time.Now()
	elapsed := now.Sub(tb.lastRefillTime)

	// è®¡ç®—è¿™æ®µæ—¶é—´åº”è¯¥ç”Ÿæˆçš„ä»¤ç‰Œæ•°
	tokensToAdd := int64(elapsed.Seconds() * float64(tb.refillRate))

	if tokensToAdd > 0 {
		tb.tokens += tokensToAdd
		if tb.tokens > tb.capacity {
			tb.tokens = tb.capacity
		}
		tb.lastRefillTime = now
	}
}

// GetAvailableTokens è·å–å½“å‰å¯ç”¨ä»¤ç‰Œæ•°
func (tb *TokenBucket) GetAvailableTokens() int64 {
	tb.mu.Lock()
	defer tb.mu.Unlock()

	tb.refill()
	return tb.tokens
}

func main() {
	// åˆ›å»ºé™æµå™¨ï¼šå®¹é‡200ï¼Œæ¯ç§’ç”Ÿæˆ100ä¸ªä»¤ç‰Œ
	limiter := NewTokenBucket(200, 100)

	fmt.Println("=== æµ‹è¯•çªå‘æµé‡ ===")
	// æ¨¡æ‹Ÿçªå‘ï¼šç¬é—´150ä¸ªè¯·æ±‚
	successCount := 0
	for i := 0; i < 150; i++ {
		if limiter.TryAcquireOne() {
			successCount++
		}
	}
	fmt.Printf("çªå‘150ä¸ªè¯·æ±‚ï¼Œé€šè¿‡: %d\n", successCount)
	fmt.Printf("å‰©ä½™ä»¤ç‰Œ: %d\n", limiter.GetAvailableTokens())

	fmt.Println("\n=== æµ‹è¯•æŒç»­æµé‡ ===")
	// æ¨¡æ‹ŸæŒç»­è¯·æ±‚
	for i := 0; i < 5; i++ {
		time.Sleep(1 * time.Second)
		pass := 0
		for j := 0; j < 120; j++ {
			if limiter.TryAcquireOne() {
				pass++
			}
		}
		fmt.Printf("ç¬¬%dç§’: å°è¯•120ä¸ªè¯·æ±‚ï¼Œé€šè¿‡ %d\n", i+1, pass)
	}

	fmt.Println("\n=== æµ‹è¯•é˜»å¡è·å– ===")
	acquired := limiter.Acquire(10, 2*time.Second)
	if acquired {
		fmt.Println("é˜»å¡è·å–10ä¸ªä»¤ç‰Œ: æˆåŠŸ")
	} else {
		fmt.Println("é˜»å¡è·å–10ä¸ªä»¤ç‰Œ: è¶…æ—¶")
	}

	fmt.Println("\n=== å¹¶å‘æµ‹è¯• ===")
	// é‡ç½®é™æµå™¨
	limiter = NewTokenBucket(100, 50)

	var wg sync.WaitGroup
	successTotal := int64(0)
	var successMu sync.Mutex

	// 10ä¸ªgoroutineå¹¶å‘è¯·æ±‚
	for i := 0; i < 10; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			localSuccess := 0
			for j := 0; j < 20; j++ {
				if limiter.TryAcquireOne() {
					localSuccess++
				}
				time.Sleep(10 * time.Millisecond)
			}
			successMu.Lock()
			successTotal += int64(localSuccess)
			successMu.Unlock()
			fmt.Printf("Goroutine %d: é€šè¿‡ %d ä¸ªè¯·æ±‚\n", id, localSuccess)
		}(i)
	}

	wg.Wait()
	fmt.Printf("å¹¶å‘æ€»é€šè¿‡: %d ä¸ªè¯·æ±‚\n", successTotal)
}
```

### åŸºäº Redis çš„åˆ†å¸ƒå¼å®ç°ï¼ˆGo + Luaï¼‰

```go
package main

import (
	"context"
	"fmt"
	"time"

	"github.com/redis/go-redis/v9"
)

// Luaè„šæœ¬ï¼šåŸå­æ€§è·å–ä»¤ç‰Œ
const tokenBucketScript = `
-- KEYS[1]: ä»¤ç‰Œæ¡¶key
-- KEYS[2]: æ—¶é—´æˆ³key
-- ARGV[1]: æ¡¶å®¹é‡
-- ARGV[2]: ä»¤ç‰Œç”Ÿæˆé€Ÿç‡ï¼ˆæ¯ç§’ï¼‰
-- ARGV[3]: å½“å‰æ—¶é—´æˆ³ï¼ˆçº³ç§’ï¼‰
-- ARGV[4]: è¯·æ±‚ä»¤ç‰Œæ•°

local capacity = tonumber(ARGV[1])
local refill_rate = tonumber(ARGV[2])
local now = tonumber(ARGV[3])
local tokens_required = tonumber(ARGV[4])

-- è·å–å½“å‰ä»¤ç‰Œæ•°å’Œä¸Šæ¬¡åˆ·æ–°æ—¶é—´
local tokens = tonumber(redis.call('GET', KEYS[1]) or capacity)
local last_refill_time = tonumber(redis.call('GET', KEYS[2]) or now)

-- è®¡ç®—åº”è¯¥ç”Ÿæˆçš„ä»¤ç‰Œæ•°
local elapsed = math.max(0, now - last_refill_time)
local tokens_to_add = math.floor((elapsed / 1e9) * refill_rate)

-- æ›´æ–°ä»¤ç‰Œæ•°ï¼ˆä¸è¶…è¿‡å®¹é‡ï¼‰
if tokens_to_add > 0 then
    tokens = math.min(capacity, tokens + tokens_to_add)
    last_refill_time = now
end

-- å°è¯•è·å–ä»¤ç‰Œ
if tokens >= tokens_required then
    tokens = tokens - tokens_required
    -- ä¿å­˜çŠ¶æ€
    redis.call('SET', KEYS[1], tokens)
    redis.call('SET', KEYS[2], last_refill_time)
    -- è®¾ç½®è¿‡æœŸæ—¶é—´ï¼ˆé¿å…Rediså†…å­˜æ³„æ¼ï¼‰
    redis.call('EXPIRE', KEYS[1], 3600)
    redis.call('EXPIRE', KEYS[2], 3600)
    return 1  -- æˆåŠŸ
else
    return 0  -- å¤±è´¥
end
`

// DistributedTokenBucket åˆ†å¸ƒå¼ä»¤ç‰Œæ¡¶é™æµå™¨
type DistributedTokenBucket struct {
	rdb        *redis.Client
	key        string  // Redis keyå‰ç¼€
	capacity   int64   // æ¡¶å®¹é‡
	refillRate int64   // æ¯ç§’ç”Ÿæˆçš„ä»¤ç‰Œæ•°
	script     *redis.Script
}

// NewDistributedTokenBucket åˆ›å»ºåˆ†å¸ƒå¼ä»¤ç‰Œæ¡¶
func NewDistributedTokenBucket(rdb *redis.Client, key string, capacity, refillRate int64) *DistributedTokenBucket {
	return &DistributedTokenBucket{
		rdb:        rdb,
		key:        key,
		capacity:   capacity,
		refillRate: refillRate,
		script:     redis.NewScript(tokenBucketScript),
	}
}

// TryAcquire å°è¯•è·å–æŒ‡å®šæ•°é‡çš„ä»¤ç‰Œ
func (dtb *DistributedTokenBucket) TryAcquire(ctx context.Context, tokensRequired int64) (bool, error) {
	keys := []string{
		dtb.key + ":tokens",
		dtb.key + ":timestamp",
	}
	args := []interface{}{
		dtb.capacity,
		dtb.refillRate,
		time.Now().UnixNano(),
		tokensRequired,
	}

	result, err := dtb.script.Run(ctx, dtb.rdb, keys, args...).Int()
	if err != nil {
		return false, err
	}

	return result == 1, nil
}

// TryAcquireOne å°è¯•è·å–1ä¸ªä»¤ç‰Œ
func (dtb *DistributedTokenBucket) TryAcquireOne(ctx context.Context) (bool, error) {
	return dtb.TryAcquire(ctx, 1)
}

// GetAvailableTokens è·å–å½“å‰å¯ç”¨ä»¤ç‰Œæ•°ï¼ˆä»…ç”¨äºç›‘æ§ï¼‰
func (dtb *DistributedTokenBucket) GetAvailableTokens(ctx context.Context) (int64, error) {
	result, err := dtb.rdb.Get(ctx, dtb.key+":tokens").Int64()
	if err == redis.Nil {
		return dtb.capacity, nil
	}
	return result, err
}

func main() {
	// è¿æ¥Redis
	rdb := redis.NewClient(&redis.Options{
		Addr:     "localhost:6379",
		Password: "", // æ ¹æ®å®é™…æƒ…å†µè®¾ç½®
		DB:       0,
	})
	defer rdb.Close()

	ctx := context.Background()

	// æµ‹è¯•è¿æ¥
	_, err := rdb.Ping(ctx).Result()
	if err != nil {
		fmt.Printf("æ— æ³•è¿æ¥Redis: %v\n", err)
		fmt.Println("è¯·ç¡®ä¿RedisæœåŠ¡æ­£åœ¨è¿è¡Œ")
		return
	}

	// åˆ›å»ºåˆ†å¸ƒå¼é™æµå™¨ï¼šå®¹é‡200ï¼Œæ¯ç§’ç”Ÿæˆ100ä¸ªä»¤ç‰Œ
	limiter := NewDistributedTokenBucket(rdb, "rate_limit:api", 200, 100)

	fmt.Println("=== åˆ†å¸ƒå¼ä»¤ç‰Œæ¡¶æµ‹è¯• ===")

	// æµ‹è¯•1ï¼šçªå‘æµé‡
	fmt.Println("\n1. æµ‹è¯•çªå‘æµé‡")
	successCount := 0
	for i := 0; i < 150; i++ {
		ok, err := limiter.TryAcquireOne(ctx)
		if err != nil {
			fmt.Printf("é”™è¯¯: %v\n", err)
			return
		}
		if ok {
			successCount++
		}
	}
	fmt.Printf("çªå‘150ä¸ªè¯·æ±‚ï¼Œé€šè¿‡: %d\n", successCount)

	tokens, _ := limiter.GetAvailableTokens(ctx)
	fmt.Printf("å‰©ä½™ä»¤ç‰Œ: %d\n", tokens)

	// æµ‹è¯•2ï¼šæŒç»­æµé‡
	fmt.Println("\n2. æµ‹è¯•æŒç»­æµé‡ï¼ˆæ¯ç§’120ä¸ªè¯·æ±‚ï¼‰")
	for i := 0; i < 3; i++ {
		time.Sleep(1 * time.Second)
		pass := 0
		for j := 0; j < 120; j++ {
			ok, _ := limiter.TryAcquireOne(ctx)
			if ok {
				pass++
			}
		}
		fmt.Printf("ç¬¬%dç§’: é€šè¿‡ %d ä¸ªè¯·æ±‚\n", i+1, pass)
	}

	// æµ‹è¯•3ï¼šæ¨¡æ‹Ÿå¤šå®ä¾‹å¹¶å‘
	fmt.Println("\n3. æ¨¡æ‹Ÿ3ä¸ªæœåŠ¡å®ä¾‹å¹¶å‘è¯·æ±‚")
	successChan := make(chan int, 3)

	for instance := 0; instance < 3; instance++ {
		go func(id int) {
			localSuccess := 0
			for j := 0; j < 50; j++ {
				ok, _ := limiter.TryAcquireOne(ctx)
				if ok {
					localSuccess++
				}
				time.Sleep(10 * time.Millisecond)
			}
			successChan <- localSuccess
			fmt.Printf("å®ä¾‹%d: é€šè¿‡ %d ä¸ªè¯·æ±‚\n", id, localSuccess)
		}(instance)
	}

	totalSuccess := 0
	for i := 0; i < 3; i++ {
		totalSuccess += <-successChan
	}
	fmt.Printf("æ€»é€šè¿‡: %d ä¸ªè¯·æ±‚\n", totalSuccess)

	fmt.Println("\næµ‹è¯•å®Œæˆï¼")
}

/*
ä½¿ç”¨è¯´æ˜ï¼š
1. å®‰è£…ä¾èµ–: go get github.com/redis/go-redis/v9
2. å¯åŠ¨Redis: docker run -p 6379:6379 redis
3. è¿è¡Œç¨‹åº: go run main.go

ä¼˜åŠ¿ï¼š
- å¤šå®ä¾‹é—´å…±äº«é™æµé…é¢
- åŸå­æ€§æ“ä½œä¿è¯ä¸€è‡´æ€§
- æ”¯æŒåŠ¨æ€è°ƒæ•´é™æµç­–ç•¥

æ³¨æ„äº‹é¡¹ï¼š
- Redisæ€§èƒ½æˆä¸ºç“¶é¢ˆæ—¶è€ƒè™‘æœ¬åœ°ç¼“å­˜
- è®¾ç½®åˆç†çš„keyè¿‡æœŸæ—¶é—´
- ç›‘æ§Redisè¿æ¥å’Œç½‘ç»œå»¶è¿Ÿ
*/
```

### Java å®ç°ï¼ˆå•æœºç‰ˆï¼‰### Go å®ç°ï¼ˆå•æœºç‰ˆï¼‰### åŸºäº Redis çš„åˆ†å¸ƒå¼å®ç°ï¼ˆGo + Luaï¼‰## äº”ã€é€‰å‹å»ºè®®

| åœºæ™¯             | æ¨èç®—æ³• | åŸå›                          |
| ---------------- | -------- | ---------------------------- |
| **API ç½‘å…³**     | ä»¤ç‰Œæ¡¶   | éœ€è¦å¤„ç†çªå‘æµé‡ï¼Œç”¨æˆ·ä½“éªŒå¥½ |
| **æ¶ˆæ¯é˜Ÿåˆ—æ¶ˆè´¹** | æ¼æ¡¶     | éœ€è¦ç»å¯¹å¹³æ»‘çš„å¤„ç†é€Ÿç‡       |
| **ç®€å•è®¡æ•°**     | å›ºå®šçª—å£ | å®ç°ç®€å•ï¼Œèµ„æºå ç”¨å°‘         |
| **ç²¾ç¡®æ§åˆ¶**     | æ»‘åŠ¨çª—å£ | æ›´å¹³æ»‘ï¼Œæ— ä¸´ç•Œé—®é¢˜           |

## å…­ã€è¿›é˜¶ä¼˜åŒ–

### 1. é¢„çƒ­æœºåˆ¶

ç³»ç»Ÿå¯åŠ¨æ—¶æ¡¶å¯èƒ½æ˜¯ç©ºçš„ï¼Œå¯ä»¥åˆå§‹åŒ–ä¸€å®šæ•°é‡çš„ä»¤ç‰Œ

### 2. åŠ¨æ€è°ƒæ•´

æ ¹æ®ç³»ç»Ÿè´Ÿè½½åŠ¨æ€è°ƒæ•´ `refillRate`

### 3. åˆ†å±‚é™æµ

```
å…¨å±€é™æµï¼ˆ1000 QPSï¼‰
  â†“
ç”¨æˆ·çº§é™æµï¼ˆæ¯ç”¨æˆ· 10 QPSï¼‰
  â†“
æ¥å£çº§é™æµï¼ˆå•æ¥å£ 5 QPSï¼‰
```

### 4. æœ¬åœ°ç¼“å­˜ + Redis

```go
// æœ¬åœ°æ¡¶å¤„ç†å¤§éƒ¨åˆ†è¯·æ±‚ï¼Œå‡å°‘Redisè°ƒç”¨
if localBucket.TryAcquire() {
    return true
}
// æœ¬åœ°å¤±è´¥æ—¶å°è¯•Redis
return redisBucket.TryAcquire()
```

---

**æ€»ç»“**ï¼šä»¤ç‰Œæ¡¶æ˜¯æœ€å¸¸ç”¨çš„é™æµç®—æ³•ï¼Œå®ƒåœ¨ä¿è¯å¹³å‡é€Ÿç‡çš„åŒæ—¶æ”¯æŒçªå‘æµé‡ï¼Œé€‚åˆç»å¤§å¤šæ•°ä¸šåŠ¡åœºæ™¯ã€‚å•æœºåœºæ™¯ç”¨æœ¬åœ°å®ç°å³å¯ï¼Œåˆ†å¸ƒå¼åœºæ™¯æ¨è Redis + Lua æ–¹æ¡ˆã€‚
